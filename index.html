<!DOCTYPE HTML>
<!--
	Dimension by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Dimension by HTML5 UP</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
		<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
		<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});</script>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<div class="logo">
							<span class="icon fa-gem"></span>
						</div>
						<div class="content">
							<div class="inner">
								<h1>Summary of ML Technologies <br />
									in Recommender System</h1>
								<p>Machine Learning (ML) & Recommender System (RS)</p>
								<!--<p>A fully responsive site template designed by <a href="https://html5up.net">HTML5 UP</a> and released<br />
								for free under the <a href="https://html5up.net/license">Creative Commons</a> license.</p> -->
							</div>
						</div>
						<nav>
							<ul>
								<li><a href="#intro">Introduction</a></li>
								<li><a href="#work">ML Applications</a></li>
								<li><a href="#about">Issues</a></li>
								<li><a href="#contact">Conclusion</a></li>
								<li><a href="#elements">References</a></li>
							</ul>
						</nav>
					</header>

				<!-- Main -->
					<div id="main">

						<!-- Intro -->
							<article id="intro">
								<h2 class="major">1. Introduction to <br />
									Recommender System</h2>
								<blockquote>When it comes to recommender system, we must ask why it exists, or rather, what is the point of its existence, and what specific problem is it designed to solve.</blockquote>
								<p>With the rapid development of modern technology and the increasing volume of data production, people are feeling increasingly helpless in the face of massive amounts of data. Information overload is an increasing problem in people's daily life. When we are browsing pages, we seek to find the web pages that are most attractive to us. However, as the Internet industry blooms, more and more information such as videos, news, and products are flooding the Internet. That's why we need a proper <b>Recommender System (RS)</b> to filter the information we are not interested in. Specifically, when talking about RS, we often think of a technology named <b>Search Engine (SE)</b>, both of which are two different mechanisms proposed to solve the information overload challenge mentioned before. Generally speaking, SE is more suited to situations where people have a clear purpose, where their search for information is translated into precise keywords, and then the SE finally returns a list of results to the user to complete the searching process. In contrast, RS may be more suitable for individuals who have no specific idea, or who have a vague purpose - in layman's terms, the user does not even know what he or she wants, which is the common usage scenario for RS. RS feeds the user's historical behaviour or interest preferences or demographic characteristics, for example, to the recommendation algorithm to generate a list of items that may be of interest to that user, where the user is passive concerning RS.</p>
								<span class="image main"><img src="images/long tail.png" alt="" /></span>
								<p>In addition, the Long Tail theory (stating that people usually focus on highly exposed items and ignore the less exposed ones)<sup>[1]</sup> explains the existence of an RS. Experiments have shown that although the sales of each product in the long tail section are small, their aggregation, as well as total profits, can be comparable to the initial section because of the length of the tail<sup>[2]</sup>. The RS provides exposure to all items, thus tapping into the potential profitability of the long-tail items, which becomes one of the advantages of RS utilization in Internet enterprises. The reason is that, compared to physical stores, online companies can set up virtual shelves, offering consumers a huge selection of products and a 'one-stop shop' with almost zero shelf cost, as it may only require an additional website.</p>
								<p>Recommender System is a technology that applies collaborative intelligence to make recommendations. These recommendations can typically be generated based on user preferences, product characteristics, the user's purchase records and other environmental factors (e.g. time of day, season, location, etc.)<sup>[3]</sup>. Essentially, it is a technical means of finding the content of interest to the user from a vast amount of information when the user's needs are not clear. Recommended items encompass movies, books, restaurants, news items, and others. The overall classification of RS architecture is illustrated in following figure, while the two main types of RS are <b>enriched recommendation</b> and <b>Collaborative Filtering (CF)</b>, there is also a special category of <b>contextual-based recommendation</b>, which uses temporal or sequential information associated with interactions as model features<sup>[4]</sup>.</p>
								<span class="image main"><img src="images/Classification.png" alt="" /></span>
								<p>In particular, the content enriched recommendation focuses on the intrinsic qualities or inherent attributes of an item, completing a task based on the information about the content of that item without relying on the user's personal opinion on it. On the other side, the CF method works through the power of collective intelligence and filtering out the items that are not of interest to the user. CF mechanism is based on the assumption that a good way to discover the real interest of a specific user is to find the other users who hold similar preferences to him and then recommend their interests to that user. At last, the contextual-based recommendation is an information-rich recommendation method that utilizes interaction factors with contextual data to support prediction details.</p>
								<h3 class="major">1.1 Challenges in Recommender System</h3>
								<p>While RS is flourishing nowadays, it also faces lots of challenges in the application layer that needed to be investigated, researched and solved in order. Here we list some typical points and analyse them carefully to find the original problems.</p>
								<ul>
									<li><b>Cold Start Problem</b>: The main purpose of an RS is to recommend plenty of subjects to a large number of users who may produce interest in them. For any Internet recommendation product, both the related subject matter and the users are changing and growing constantly, so the system must often face the emergence of new batches of these two items. Therefore, the cold start problem of the recommendation system refers to that how to recommend the existing subject matter to new users to satisfy them since we don't know what they like, and how to distribute the new subject matter to users who like it since it hasn't been rated <sup>[5]</sup>. There are some general ideas that help to solve the cold start problem, which includes collecting user interest information at the registration stage, providing non-personalized recommendation services, performing recommendation tasks based on content, adopting a strategy based on relational delivery, etc<sup>[6]</sup>.</li>
									<li><b>Sparsity Problem</b>: Sparsity problem is one of the essential issues encountered by RS and it refers to data sparsity in the user rating matrix, which may have a great influence on recommendation task performance<sup>[5]</sup>. Generally, it happens when a user possesses a large matrix storing data of his or her purchased products or favourite music or watched movies, but the user did not rate these items. In this way, the user-item matrix dimension increases, as well as data sparsity evolves, leading to poor quality of RS results<sup>[7]</sup>. CF suffers from this problem as its performance depends a lot on the rating matrix.</li>
									<li><b>Scalability</b>: The scalability of algorithms is another significant challenge faced by RS as we have a larger scale of data nowadays. To be specific, scalability is a property of a system that indicates its ability to handle an ever-growing volume of information elegantly. In reality, with the tremendous growth of information on the Internet and the explosion of user data, it becomes more challenging for only one RS algorithm to deal with the whole process. It is possible that some recommendation algorithms provide better results when they are applied on relatively small datasets, but may reflect inefficient or poorer performance on very large datasets<sup>[8]</sup>. Therefore, some advanced large-scale evaluation methods are necessary to solve this problem<sup>[9]</sup>.</li>
									<li><b>Privacy Issues</b>: In order to generate high-quality personalised recommendations, RSs must collect as much user data as possible and maximize their use. On the other hand, this may produce a negative impression in the minds of users, as the system remains access to their private information and is often collecting private data from them<sup>[8]</sup>. Therefore, the technology needs to be designed in such a way that user data can be used sensibly, carefully and discreetly, ensuring that information about the user's true preferences is not freely available to malicious people<sup>[10]</sup>. Besides, the problem may be addressed by Federal Learning.</li>
									<li><b>Information Cocoons</b>: The information cocoon is a terrible phenomenon prevalent in modern society, literally meaning that information is blocked by a cocoon of worms, reflecting a social problem that is now diffused with the popularity of personalised recommendations<sup>[11]</sup>. Specifically, for example, if user X is a sports fan, then most of the information X gets is sports-related, and it is difficult to get other information related to music or the military since the platform pursues the click-through rate and will keep pushing content of interest to X to get high ad views. Over time, due to the information cocoon, users have single access to external information, and X's social circle and horizon may also become narrower. It would be pathological if the whole society fell into the information cocoon effect of personalised recommendation systems. As a result, the cross-domain recommendation method can be an effective solution to provide diverse recommendations to users.</li>
								</ul>
								<!--
								<p><b>Cold Start Problem</b>: The main purpose of an RS is to recommend plenty of subjects to a large number of users who may produce interest in them. For any Internet recommendation product, both the related subject matter and the users are changing and growing constantly, so the system must often face the emergence of new batches of these two items. Therefore, the cold start problem of the recommendation system refers to that how to recommend the existing subject matter to new users to satisfy them since we don't know what they like, and how to distribute the new subject matter to users who like it since it hasn't been rated by anyone \cite{sharma2013survey}. There are some general ideas that help to solve the cold start problem, which includes collecting user interest information at the registration stage, providing non-personalized recommendation services, performing recommendation tasks based on content, adopting a strategy based on relational delivery, etc \cite{saveski2014item}.</p>
								<p><b>Sparsity Problem</b>: Sparsity problem is one of the essential issues encountered by RS and it refers to data sparsity in the user rating matrix, which may have a great influence on recommendation task performance \cite{sharma2013survey}. Generally, it happens when a user possesses a large matrix storing data of his or her purchased products or favourite music or watched movies, but the user did not rate these items. In this way, the user-item matrix dimension increases, as well as data sparsity evolves, leading to poor quality of RS results \cite{mohamed2019recommender}. CF suffers from this problem as its performance depends a lot on the rating matrix.</p>
								<p><b>Scalability</b>: The scalability of algorithms is another significant challenge faced by RS as we have a larger scale of data nowadays. To be specific, scalability is a property of a system that indicates its ability to handle an ever-growing volume of information elegantly. In reality, with the tremendous growth of information on the Internet and the explosion of user data, it becomes more challenging for only one RS algorithm to deal with the whole process. It is possible that some recommendation algorithms provide better results when they are applied on relatively small datasets, but may reflect inefficient or poorer performance on very large datasets \cite{kumar2016approaches}. Therefore, some advanced large-scale evaluation methods are necessary to solve this problem \cite{george2005scalable}.</p>
								<p><b>Privacy Issues</b>: In order to generate high-quality personalised recommendations, RSs must collect as much user data as possible and maximize their use. On the other hand, this may produce a negative impression in the minds of users, as the system remains access to their private information and is often collecting private data from them \cite{kumar2016approaches}. Therefore, the technology needs to be designed in such a way that user data can be used sensibly, carefully and discreetly, ensuring that information about the user's true preferences is not freely available to malicious people \cite{lam2006you}. Besides, the problem may be addressed by Federal Learning.</p>
								<p><b>Information Cocoons</b>: The information cocoon is a terrible phenomenon prevalent in modern society, literally meaning that information is blocked by a cocoon of worms, reflecting a social problem that is now diffused with the popularity of personalised recommendations \cite{cantador2015cross}. Specifically, for example, if user X is a sports fan, then most of the information X gets is sports-related, and it is difficult to get other information related to music or the military since the platform pursues the click-through rate and will keep pushing content of interest to X to get high ad views. Over time, due to the information cocoon, users have single access to external information, and X's social circle and horizon may also become narrower. It would be pathological if the whole society fell into the information cocoon effect of personalised recommendation systems. As a result, the cross-domain recommendation method can be an effective solution to provide diverse recommendations to users.</p>
								-->
								<h3 class="major">1.2 ML Applications Cases in Recommender System</h3>
								<p><b>Machine Learning (ML)</b> is a branch of <b>Artificial Intelligence (AI)</b>, this technology aims to give machines the ability to think and learn like humans, as well as identify and acquire information from the real world, furthermore, it can also improve its performance by training models on its existing knowledge. In the enormous amount of recommendation algorithms, ML plays an important role as it uses mathematical or statistical analysis to learn, draw conclusions or infer data<sup>[12]</sup>. Here we will present several ML application cases in the RS domain across some well-known companies.</p>
								<h4 class="major">1.2.1 Amazon</h4>
								<p>Amazon is one of the world's largest eCommerce enterprises that possesses a giant variety of products on sale. It is famous for its extremely accurate result on customized recommendations in its website contents, and for instance, the following figures show parts of my Amazon homepage, which certifies that it knows me well. Moreover, it has been working on an algorithm that is responsible for processing and analysing a huge amount of data and predicting what users like to improve their customer experience and therefore increase sales as well as profits, which designs based on AI and ML.</p>
								<span class="image main"><img src="images/amazon1.PNG" alt="" /></span>
								<span class="image main"><img src="images/amazon2.PNG" alt="" /></span>
								<p>Particularly, as mentioned before, an accurate recommendation result always relies on the preponderance of data. Therefore, the recommendation engine usually collects two types of information, including general data about users and items, as well as relations or dependencies data between them<sup>[13]</sup>. Grasping the existing attitudes of users towards online shops will give RS insight into the real mechanisms that govern customers' purchasing decisions. Besides, Amazon's recommendation algorithm focuses on three different aspects of operation relationship, they are user-product, product-product, and user-user, all of which help to build an integral relationship structure between the user and their product of interest.</p>
								<h4 class="major">1.2.2 Netflix</h4>
								<p>As the world's leading Internet television network, Netflix has more than 160 million members range over 190 countries, they enjoy various kinds of videos every day, including feature films, science fiction films, original series, etc<sup>[14]</sup>. In consequence, Netflix invests a lot in AI and ML techniques to use them in diverse areas, especially for RS, to optimize its RS service, increase user satisfaction with the movie RS and maintain the willingness of users to continue to choose Netflix. Moreover, the ML algorithm works creatively behind the screen that acquiring bunches of data every day and updating itself to guess more accurately about what a user would like to watch on that day. Combined with data science, ML in Netflix enables the RS to personalise the user experience according to his or her preferences history.</p>
								<p>The following figure shows the overall procedure of how Netflix RS works. Generally, the recommendations are on the strength of users' behaviour relating to the searching or viewing, as well as their ratings regard to each movie they watched<sup>[15]</sup>. Furthermore, some ML algorithms are applied to implement the recommendation result of each specific user, which is in the form of list representation. In detail, whenever a user visits one of Netflix's services, the RS estimates the probability that the user will watch a particular piece of content based on the following factors<sup>[16]</sup>:
									<ol>
										<li>Some basic information about the title, categories, year of release and more;</li>
										<li>Length of time a viewer spends on watching the programme and the time of the day a viewer watches, since human's watching behaviour may vary with lots of factors;</li>
										<li>Viewers feedback or interactions with the content, for example, the comments or ratings;</li>
										<li>Information on other viewers with similar viewing preferences and tastes, which is beneficial to construct the user-user relationship matrix for CF implementation.</li>
									</ol>
									<!-- (1) Some basic information about the title, categories, year of release and more; (2) Length of time a viewer spends on watching the programme and the time of the day a viewer watches, since human's watching behaviour may vary with lots of factors; (3) Viewers feedback or interactions with the content, for example, the comments or ratings; (4) Information on other viewers with similar viewing preferences and tastes, which is beneficial to construct the user-user relationship matrix for CF implementation.
										-->
								<p>Netflix's ML-based recommendation algorithm takes information from users themselves and iterates on it. Every time a user watches a movie or a video, it gathers data that provides the ML algorithm behind the scenes with a new dataset and updates it. The more viewing operation that takes place, the more accurate and compatible the algorithm becomes.</p>
								<span class="image main"><img src="images/Netflix-recommendation-system.jpg" alt="" /></span>
							</article>

						<!-- Work -->
							<article id="work">
								<h2 class="major">ML Technologies in Recommender System</h2>
								<h3 class="major">Graph Neural Networks for Recommender System</h3>
								<p>In recommender systems, user-item interactions can be naturally formulated as a bipartite graph (as shown in Fig. \ref{fig:bipartitegraph}), whose nodes indicate users or items and edges indicate the interaction relationships between users and items such as browsing and purchase \cite{guo2021syntax}. Graph Neural Networks (GNNs) are powerful tools for graph mining and thus can be naturally introduced into RS. In RS, we desire to obtain better user/item representations to predict whether a user will be interested in a particular item, and this is equivalent to the link prediction task on a bipartite graph to predict whether two nodes have the potential to build an edge based on their similarities. To get better node representations, GNNs recursively aggregate the information from neighbour node and learn the subgraph structure around a certain node \cite{zhou2020graph}, thus in this way, high-order connectivity is introduced into the node representation, instead of only 1-hop connectivity in Matrix Factorization (MF) model.</p>
								<span class="image main"><img src="images/GNN1.PNG" alt="" /></span>
								<p>In this section, we will initially introduce the definition of graphs and GNN implementation process, then discuss the GNN-based RS in details. Normally, a graph can be represented as $\mathcal{G}= (\mathcal{V}, \mathcal{E})$, where $\mathcal{V}$ is the nodes set and $\mathcal{E}$ means the edges set. Suppose $v_i \in \mathcal{V}$ refers to a node, $e_{ij} = (v_i, v_j) \in \mathcal{E}$ refers to an edge pointing from $v_j$ to $v_i$, and $\mathcal{N}(v)=\{u \in \mathcal{V} \mid(v, u) \in \mathcal{E}\}$ refers to the neighborhood of node $v$. From a network architecture point of view, GNNs stack multiple propagation layers that be composed of aggregation and update operations. The propagation formulation is \cite{wu2020graph}:
									\begin{equation} \label{GNN}
									\begin{split}
										&Aggregation: \quad \mathbf{n}_{v}^{(l)}=\operatorname{Aggregator}_{l}\left(\left\{\mathbf{h}_{u}^{l}, \forall u \in \mathcal{N}_{v}\right\}\right),\\
										&Update: \quad \mathbf{h}_{v}^{(l+1)}=\operatorname{Updater}_{l}\left(\mathbf{h}_{v}^{(l)}, \mathbf{n}_{v}^{(l)}\right),
									\end{split}
									\end{equation}
								</p>
								<p>where $\mathbf{h}_{u}^{l}$ denotes the representation of node $u$ at $l^{th}$ layer, $\operatorname{Aggregator}_{l}$ and $\operatorname{Updater}_{l}$ denotes the aggregation operation and update operation at $l^{th}$ layer respectively. The aggregation step mainly uses mean-pooling \cite{hamilton2017inductive, li2015gated} algorithm or attention mechanism \cite{velivckovic2017graph} to implement the specific task. The update step integrates the representation of both the central node and aggregated neighbour node together into the new representation of the central node by the means of sum operation, nonlinear concatenation, GRU mechanism, etc \cite{hamilton2017inductive, li2015gated}. The above describes the basic principles and procedures of GNN implementation.</p>
								<p>According to the type of information involved in the project and the specific purpose of the task, existing GNN-based recommendation models can be classified as user-item collaborative filtering, sequential recommendation, social recommendation, knowledge graph-based recommendation, and other tasks \cite{wu2020graph}. Among these other tasks are POI recommendation and bundle recommendation. Why are the models classified in this way? Firstly, the structure of the graph in GNN depends a lot on the information type. For instance, a social network is naturally a homogeneous graph, while user-item interactions can be considered as a bipartite graph or as two homogeneous graphs, so they hold differences on this point. Furthermore, building an effective GNN model also relies on the information type, since it needs to complete the aggregation and update operations as well as consider network depth. Therefore, the knowledge graph-based recommendation can be classified as it has various types of entities and relationships. </p>
								<p>Overall, as RS holds a large amount of data and variety, the GNN can address RS's current challenges for the following reasons: (1) \textbf{Data Structuring}, GNN provides a unified approach to utilizing available data by representing all data as nodes and edges on a graph; (2) \textbf{High-order connectivity}, stacking GNN layers can naturally introduce high-order association character and enhance CF signals; (3) \textbf{Supervised signals}, GNN uses semi-supervised signals in representation learning to alleviate the problem of less supervised signals, also known as sparse interaction numbers; (4) \textbf{Information updated}: GNN can also learn the compressed representation of edge information, and the learned vectors can be integrated into the representation of interactive data to improve system performance.</p>
								<h3 class="major">Natural Language Processing <br />
									in Recommender System</h3>
								<p>Natural Language is everywhere in RS scenarios such as news recommendations and product recommendations. Contexts are vital in recommendation since they always reflect item properties, hence powerful Natural Language Understanding (NLU) model and Natural Language Processing (NLP) technologies are needed to model item properties and achieve high-quality recommendation results efficiently.</p>
								<p>Generally, the NLP applications in search and recommendation systems consist of three aspects \cite{guo2019deep}: (1) \textbf{Query and document understanding}, such as news recommendation, opinion mining, intent prediction, etc; (2) \textbf{Retrieval and ranking}, including information retrieval and ranking recommendation; (3) \textbf{Language generation}, such as conversation recommendation and query reformulation.</p>
								<p>Initially, take news recommendations for example, several attempts are made to boost the performance by incorporating NLP technologies. Wu \textit{et al}. \cite{10.1145/3292500.3330665} propose to use a Convolution Neural Network (CNN) to learn hidden representations of news articles by encoding their titles. As for the users, they learn the representations of viewers by encoding their previously browsed news. They propose using both words- and news-level attention mechanisms to help the model attend to significant words and news articles because different words and news articles may have varied informativeness for representing news and users</p>
								<span class="image main"><img src="images/NLP1.PNG" alt="" /></span>
								<span class="image main"><img src="images/NLP2.PNG" alt="" /></span>							
								<p>As shown in Fig. \ref{fig:NPA}, the left part describes two users and their news browsing history, while the arrows and boxes coloured in orange and blue represent their interesting news and words respectively. But there is a problem that users' preferences may differ from the content they click on, therefore a neural news recommendation model with personalized attention (NPA) was designed to give different informativeness for different users. The specific architecture of the personalized attention module is presented in the right part, while $c_i$ denotes the representation of the $i$-th word, $\alpha_i$ denotes the attention weight of the $i$-th word, and $r$ denotes the final contextual representation of the news title. In this way, the news encoder is applied to all news that has been or will be clicked by the users to acquire their mathematical representations as output. Therefore, the NPA is able to find and emphasize some keywords from news titles based on users' personal preferences.</p>
								<p>Besides, opinion mining can be of great significance in contemporary RSs since the feedback from users composes a vital part of RS data collection requests. Hu \textit{et al}. \cite{hu2004mining} apply text summarization to construct the link between users and features of the product on which the customers have expressed their opinions, thus providing information for the CF recommendation algorithm. Specifically, there are three steps: (1) Mine the product features that have been rated by customers by opinion word extraction and text processing; (2) Get customers' attitudes using sentiment classification in NLP; (3) Implement text summarization. With all the procedures above finished, the mined features can play a key role in implementing an NLP-based recommendation algorithm.</p>
								<p>Moreover, for retrieval and ranking applications, the designed mechanisms are supposed to hold a low latency, for example, the retrieval results need to be returned to the user interface within a certain period. However, most of the NLP algorithms are based on neural networks, which are computationally intensive and difficult to deploy on a lightweight website, thus Song \textit{ti al}. \cite{han2015deep} introduce the `deep compression‘ method that can compress deep neural networks with pruning, trained quantization and Huffman coding so that to meet the RS requirements. Furthermore, the semantic matching \cite{hu2014convolutional} is also significant to RS since it should be able to recognize and process different languages automatically. In the end, for the conversation recommendation task, some researchers designed a Recurrent Neural Network-based Question & Recommendation model \cite{christakopoulou2018q} to complete the video recommendations on YouTube, which can efficiently utilize the feedback from users' answers to improve their model's prediction accuracy during the conversation.</p>
								<h3 class="major">Mutltimodal Recommender System</h3>
								<p>In recommendation systems, the interactions between users and items compose an essential part, but the preferences data such as users' ratings and clicks are usually spare in distribution. Therefore, one promising attempt to decrease this sparsity as well as tackle the cold start problem mentioned in Chapter 1 is to leverage valuable external knowledge as additional information, which is able to encode auxiliary data on how users interact with items \cite{truong2021multi, sun2020multi}. There is an important but easily overlooked point that we need to consider in the data modalities, for example, the auxiliary information is supposed to contain item details' descriptions in texts, product images, user social networks, etc. As a result, the RS can incorporate, integrate and transform different kinds of data into multimodal recommendation models from a comprehensive perspective.</p>
								<p>Cornac \cite{salah2020cornac} is a comparative Python-based framework for multimodal RSs, it has three key features: (1) Multimodality Support, the RS can learn from multiple modalities at the same time. (2) Scalability, the framework is a collection of iterators for easy stochastic optimization and it harnesses the Python ecosystem for implementing efficient operations. (3) Accessibility & Reproducibility: it is open-source and users are convenient to choose any real-world benchmark datasets in their applications. Besides, Cornac's infrastructure is illustrated in figure as follows, in which the blue arrows indicate the interaction flows by running the experiments, and the thin orange arrows represent the cross-modality data utilization and transformations.</p>
								<img src="images/cornac.PNG" alt="" />
								<p>The whole picture describes the basic routines for Cornac experimentation, exploration, and comparisons. First of all, it facilitates working with auxiliary data, in which three different modality classes are considered. Text modality performs algorithms on raw texts as well as producing reasonable representations, such as bag-of-words, according to specific situations. Image Modality processes image data using VBPR or VMF models. Graph Modality aims to construct pairwise relations between users and various items by data encoding. Besides, some evaluation methods such as ratio split and cross-validation are employed to find the rational combination of model parameters. Furthermore, it applies unimodal and multimodal models to acquire the deeper layer features from represented data. In the end, with all experiments accomplished, the results of the rating and ranking tasks are assessed individually according to the requirements of their practical objectives.</p>								
								<p>Except for the integrated framework above, there is another recommendation modal named MMGCN (Multi-modal Graph Convolution Network) \cite{wei2019mmgcn} designed to realize the personalized micro-video recommendation on lots of social platforms such as Tiktok and Kwai. Under this circumstance, it is vital to collect data from different modalities, including textual, visual, and acoustic, to acquire the representation learning in each of them. MMGCN harnesses the idea of message passing in GNN by building a user-item bipartite graph in each modality and using topological structure as well as neighbours' features to signify each node. As a viewer may hold different perspectives on each modality of the video, for example, he or she may be attracted by the textual description, but feel disappointed with the images and sounds played in the video, it is crucial to consider the multimodal preferences of the user to construct a comprehensive RS. MMGCN solves this challenge by setting different modalities that serve their specific channel to explore what is the user really interested in.</p>
								<p>Knowledge Graph (KG) is an efficient tool for adding auxiliary information in RS construction. The Multi-modal Knowledge Graph Attention Network (MKGAT) \cite{sun2020multi} combines the advantages of KGs and attention mechanism to aggregate multimodal embedding representations to achieve an integrated recommendation algorithm. As a whole, when RS considers multimodal factors at the same time and is able to fuse the different modalities effectively, it can address many of the challenges currently faced, such as data sparsity and cold start problems, and simultaneously improve system performance and recommendation accuracy.</p>
							</article>

						<!-- About -->
							<article id="about">
								<h2 class="major">Issues about ML Technologies <br />
									in Recommender System</h2>
								<p>Although ML technologies boost the performance of RS models by a large margin, concerns about abusing such powerful tools are still in discussion. </p>
								<p><b>1) Privacy}</b>: Privacy issue is one of the most concerned problems \cite{DBLP:conf/recsys/MintoHLH21}. RSs are frequently trained by ML models using data from centralized user interactions, such as views or clicks, to generate a more personalized recommendation result to satisfy the users \cite{milano2020recommender}. However, it is a trade-off that the more accurate recommendations need larger amounts of user data (which is part of the essence of the ML model), while the collecting and management of potentially sensitive data by the recommender may lead to severe privacy problems. Since user profiles can be built on those data, if they leaked, catastrophic consequences will come. Moreover, the development of privacy and security issues in RS is further exacerbated by the data-sharing agreements jointly reached by different social platforms, as it means that when a user's personal information is found to be compromised on any one of them, his or her sensitive content on the rest of the platforms is potentially at risk.</p>
								<p>As a result, in order to prevent the leakage of personal information, it is necessary to obscure sensitive personal information of users through effective encryption techniques, while generating recommendations by making the system inaccessible to the real information. To address these challenges, an efficient privacy-preserving recommender system using homomorphic encryption has been designed \cite{badsha2016practical}, in which the whole recommendation process can be completed without collecting the real personal information.</p>
								<p><b>2) Bias</b>: Bias issue has gained widely attention of researchers \cite{DBLP:journals/corr/abs-2010-03240}. In practice, the RS model is fitted to data from user behaviour by various ML techniques, however, the data is observational rather than experimental, and most of the recommendation models rely purely on error-based evaluation metrics. As a result, several biases, such as selection bias, position bias, exposure bias, and popularity bias, are common in the data \cite{chen2020bias}. Fitting data without taking into account the inherent biases would lead to several serious concerns, such as discrepancies between offline and online metrics, a decrease in user experience and trust in the recommendation service, and so on. There are three main factors \cite{chen2021bias} to cause this effect: (1) User behaviour data, normally a user's behaviour occurs based on the content that has been recommended. (2) Items presented unevenly in the data. The principles of some ML models make the data inherently sparse, leading to some popular items usually receiving more attention, thus remaining a larger impact on the model training. (3) Feedback loop, similar to the negative feedback mechanism: a user produces behaviour based on what is exposed to him or her, thus making the bias more serious. </p>
								<p>Generally, the bias created by the machine has the potential to lead to adverse social effects from inequitable development to polarisation. And research results \cite{khenissi2020modeling} have shown that RSs are biased and depend heavily on the prior exposure of the user. Moreover, the studied biases continuously reduce the diversity of output recommendations. Therefore the mutual contact behaviour of users and items needs to be taken into account in the design of future recommendation mechanisms to reduce bias efficiently.</p>
								<p><b>3) Explainability \& Interpretability</b>: Recommendations can boost the system's openness, persuasiveness, and trustworthiness. However, when learning user or object feature representations for rendering recommendations, latent factor models such as MF and neural networks suffer from a lack of interpretability and explainability, since they fail to analyse the real motivations that drive the occurrence of user's behaviour. Explaining why a user likes an item is as crucial as the accuracy of the rating prediction in a modern RS, as it can provide valuable information on investigating how the recommendation model is effective and what researchers could do to improve the system's performance. Several attempts have been made to address the issue by utilizing metadata such as user-defined categories and subjects from user review texts or item descriptions to illuminate users' preferences. Furthermore, most existing interpretable recommendation models treat the user's preferences as constant to produce a static interpretation \cite{chen2019dynamic}. However, in a real scenario, users' preferences may be dynamic since people's hobbies and purchases can be influenced a lot by time and surroundings, therefore they may hold different opinions on the same item at a different stage. Consequently, a RS that is both interpretable and explainable must be highly observable and reducible to user behaviour, and it also needs to take into account the dynamics of reality in order to be able to update the model in real-time and achieve better recommendations.</p>
							</article>

						<!-- Contact -->
							<article id="contact">
								<h2 class="major">Conclusion</h2>
								<p>Nowadays the prosperous recommendation technique has demonstrated great success in the modern and sophisticated world that is filled with e-commerce applications as well as social platforms, as it plays a significant role in helping customers discover what they really like and buy products in their demand, as well as recommending friends that they may be interested in. This article focuses on the ML technologies application in RS and verifies their effectiveness from various aspects. First of all, the introduction to RS provides an overall view of its origins, the current state of its development and the classification of some classical algorithms. Then it is followed by a description of some of the challenges currently being faced in the field of RSs, such as the cold start problem and information cocoons, part of which will be discussed and addressed in Chapter 2. The ML application cases in RS illustrate the vivid examples of Amazon and Netflix applying RS for the user and content recommendations.</p>
								<p>As a whole, the application of various ML algorithms, including GNN, NLP and multimodal, to RSs has demonstrated the effectiveness of ML models in the steps of user profile construction, user-item relationship modelling, user preference feature extraction and parameter training. In the future, the possible development directions in this field could focus more on the issues and concerns mentioned in the article, such as filling the data aggregation gap between different modalities, utilizing user information more securely, minimising bias and positive feedback effects, and constructing explainable RSs, etc. Furthermore, most of these developments are closely linked to ML algorithms; in other words, ML is an indispensable part of RS and it is also one of the necessary conditions for RS to flourish. Therefore, as ML techniques continue to develop, RS algorithms will also have the ability to address more challenges.</p>
							</article>

						<!-- Elements -->
							<article id="elements">
								<h2 class="major">Elements</h2>

								<section>
									<h3 class="major">Text</h3>
									<p>This is <b>bold</b> and this is <strong>strong</strong>. This is <i>italic</i> and this is <em>emphasized</em>.
									This is <sup>superscript</sup> text and this is <sub>subscript</sub> text.
									This is <u>underlined</u> and this is code: <code>for (;;) { ... }</code>. Finally, <a href="#">this is a link</a>.</p>
									<hr />
									<h2>Heading Level 2</h2>
									<h3>Heading Level 3</h3>
									<h4>Heading Level 4</h4>
									<h5>Heading Level 5</h5>
									<h6>Heading Level 6</h6>
									<hr />
									<h4>Blockquote</h4>
									<blockquote>Fringilla nisl. Donec accumsan interdum nisi, quis tincidunt felis sagittis eget tempus euismod. Vestibulum ante ipsum primis in faucibus vestibulum. Blandit adipiscing eu felis iaculis volutpat ac adipiscing accumsan faucibus. Vestibulum ante ipsum primis in faucibus lorem ipsum dolor sit amet nullam adipiscing eu felis.</blockquote>
									<h4>Preformatted</h4>
									<pre><code>i = 0;

while (!deck.isInOrder()) {
    print 'Iteration ' + i;
    deck.shuffle();
    i++;
}

print 'It took ' + i + ' iterations to sort the deck.';</code></pre>
								</section>

								<section>
									<h3 class="major">Lists</h3>

									<h4>Unordered</h4>
									<ul>
										<li>Dolor pulvinar etiam.</li>
										<li>Sagittis adipiscing.</li>
										<li>Felis enim feugiat.</li>
									</ul>

									<h4>Alternate</h4>
									<ul class="alt">
										<li>Dolor pulvinar etiam.</li>
										<li>Sagittis adipiscing.</li>
										<li>Felis enim feugiat.</li>
									</ul>

									<h4>Ordered</h4>
									<ol>
										<li>Dolor pulvinar etiam.</li>
										<li>Etiam vel felis viverra.</li>
										<li>Felis enim feugiat.</li>
										<li>Dolor pulvinar etiam.</li>
										<li>Etiam vel felis lorem.</li>
										<li>Felis enim et feugiat.</li>
									</ol>
									<h4>Icons</h4>
									<ul class="icons">
										<li><a href="#" class="icon brands fa-twitter"><span class="label">Twitter</span></a></li>
										<li><a href="#" class="icon brands fa-facebook-f"><span class="label">Facebook</span></a></li>
										<li><a href="#" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
										<li><a href="#" class="icon brands fa-github"><span class="label">Github</span></a></li>
									</ul>

									<h4>Actions</h4>
									<ul class="actions">
										<li><a href="#" class="button primary">Default</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
									<ul class="actions stacked">
										<li><a href="#" class="button primary">Default</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
								</section>

								<section>
									<h3 class="major">Table</h3>
									<h4>Default</h4>
									<div class="table-wrapper">
										<table>
											<thead>
												<tr>
													<th>Name</th>
													<th>Description</th>
													<th>Price</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Item One</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Two</td>
													<td>Vis ac commodo adipiscing arcu aliquet.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Three</td>
													<td> Morbi faucibus arcu accumsan lorem.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Four</td>
													<td>Vitae integer tempus condimentum.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Five</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2"></td>
													<td>100.00</td>
												</tr>
											</tfoot>
										</table>
									</div>

									<h4>Alternate</h4>
									<div class="table-wrapper">
										<table class="alt">
											<thead>
												<tr>
													<th>Name</th>
													<th>Description</th>
													<th>Price</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>Item One</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Two</td>
													<td>Vis ac commodo adipiscing arcu aliquet.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Three</td>
													<td> Morbi faucibus arcu accumsan lorem.</td>
													<td>29.99</td>
												</tr>
												<tr>
													<td>Item Four</td>
													<td>Vitae integer tempus condimentum.</td>
													<td>19.99</td>
												</tr>
												<tr>
													<td>Item Five</td>
													<td>Ante turpis integer aliquet porttitor.</td>
													<td>29.99</td>
												</tr>
											</tbody>
											<tfoot>
												<tr>
													<td colspan="2"></td>
													<td>100.00</td>
												</tr>
											</tfoot>
										</table>
									</div>
								</section>

								<section>
									<h3 class="major">Buttons</h3>
									<ul class="actions">
										<li><a href="#" class="button primary">Primary</a></li>
										<li><a href="#" class="button">Default</a></li>
									</ul>
									<ul class="actions">
										<li><a href="#" class="button">Default</a></li>
										<li><a href="#" class="button small">Small</a></li>
									</ul>
									<ul class="actions">
										<li><a href="#" class="button primary icon solid fa-download">Icon</a></li>
										<li><a href="#" class="button icon solid fa-download">Icon</a></li>
									</ul>
									<ul class="actions">
										<li><span class="button primary disabled">Disabled</span></li>
										<li><span class="button disabled">Disabled</span></li>
									</ul>
								</section>

								<section>
									<h3 class="major">Form</h3>
									<form method="post" action="#">
										<div class="fields">
											<div class="field half">
												<label for="demo-name">Name</label>
												<input type="text" name="demo-name" id="demo-name" value="" placeholder="Jane Doe" />
											</div>
											<div class="field half">
												<label for="demo-email">Email</label>
												<input type="email" name="demo-email" id="demo-email" value="" placeholder="jane@untitled.tld" />
											</div>
											<div class="field">
												<label for="demo-category">Category</label>
												<select name="demo-category" id="demo-category">
													<option value="">-</option>
													<option value="1">Manufacturing</option>
													<option value="1">Shipping</option>
													<option value="1">Administration</option>
													<option value="1">Human Resources</option>
												</select>
											</div>
											<div class="field half">
												<input type="radio" id="demo-priority-low" name="demo-priority" checked>
												<label for="demo-priority-low">Low</label>
											</div>
											<div class="field half">
												<input type="radio" id="demo-priority-high" name="demo-priority">
												<label for="demo-priority-high">High</label>
											</div>
											<div class="field half">
												<input type="checkbox" id="demo-copy" name="demo-copy">
												<label for="demo-copy">Email me a copy</label>
											</div>
											<div class="field half">
												<input type="checkbox" id="demo-human" name="demo-human" checked>
												<label for="demo-human">Not a robot</label>
											</div>
											<div class="field">
												<label for="demo-message">Message</label>
												<textarea name="demo-message" id="demo-message" placeholder="Enter your message" rows="6"></textarea>
											</div>
										</div>
										<ul class="actions">
											<li><input type="submit" value="Send Message" class="primary" /></li>
											<li><input type="reset" value="Reset" /></li>
										</ul>
									</form>
								</section>

							</article>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<p class="copyright">&copy; Untitled. Design: <a href="https://html5up.net">HTML5 UP</a>.</p>
					</footer>

			</div>

		<!-- BG -->
			<div id="bg"></div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
